---
title: "Preliminary HCAccess Work"
author: "Maya Reed McDaniel"
date: "12/29/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Recap:

```{r}
# load packages
library(httr)
library(jsonlite)
library(dplyr)

# construct a query filter (aiming for `{"organ" : {"is" : ["pancreas"]}}`)
r_filter <- list(
    organ = list(
        is = "pancreas"
    )
)

# takes list and makes it json
json_filter <- jsonlite::toJSON(r_filter)
# need to encode url so that curly braces are not escaped, but treated as legal characters
encoded_filter <- utils::URLencode(json_filter, reserved = TRUE)
encoded_filter

# putting together base url, endpoint, and other parameters
base_url <- "https://service.dev.singlecell.gi.ucsc.edu"
endpoint <- "/index/projects"

params <- list(
    catalog = "dcp2",
    filters = encoded_filter,
    size = 100,
    sort = "projectTitle",
    order = "asc"
)

# further parameter processing; do names(params) to get parameter key names
names(params)
param_key_value <- paste(names(params), params, sep="=")
param_key_value

# format the query by collapsing into single string separated by `&`
query <- paste(param_key_value, collapse = "&")
query

# form the URL for the GET query
# paste with no sep
url <- paste0(
    base_url,
    endpoint,
    "?",
    query
)

url

# Now that we have url, make request using `httr` package
# wrapping in a try-catch block

response <- httr::GET(url)
tryCatch({
    httr::stop_for_status(response) # make sure response code isn't 400 or higher
}, error = function(e) {
    ## convert error into a simple 'message' so execution continues
    message(e)
})

# output headers as a string
httr::headers(response) %>%
        utils::str()

# response content
lst <- httr::content(response)
# lst
```

---
## 2. Figure out how to parse return value
- our goal here is to extract a list of project titles for the projects returned by our query

- As a start, here are the 'names' of list elements making up the response's content, and the length (number of elements of each element)
      
```{r}
names(lst)
lengths(lst)
```

> Any index, when queried, returns a JSON array of ***hits***. Each hit represents a metadata entity. Nested in each hit is a summary of the properties of entities associated with the hit.

- The hits (4 in total) are unnamed; unnamed elements can be accessed via a 1-based double square bracket

```{r}
names(lst$hits[[1]])
```

- The path to the first project title matching the filter is (in two equivalent ways)
      
```{r}
t1 <- lst$hits[[1]]$projects[[1]]$projectTitle
t1
t2 <- lst[["hits"]][[1]][["projects"]][[1]][["projectTitle"]]
t2
identical(t1, t2)
```

- Use `sapply()` with `X = lst$hits` to generate a vector of project titles matching our query.
```{r}
# function for extracting project titles
extract_proj_titles <- function(X = list()){
    # print(identical(X, lst[["hits"]]))
    proj_titles <- c()
    num_hits <- length(X)
    # print(paste('num_hits:', num_hits))
    for (hit_ind in 1:num_hits){
        current_hit <- X[[hit_ind]]
        num_projs <- length(current_hit$projects)
        for (proj_ind in 1:num_projs){
            current_proj <- current_hit$projects[[proj_ind]]
            proj_titles <- append(proj_titles, current_proj$projectTitle)
        }
    }
    
    return(proj_titles)
}

sapply(X = list(lst$"hits"), FUN = extract_proj_titles)
```

---
## 3. What information in is `lst$pagination` and `lst$termFacets`?

```{r}
names(lst$pagination)
lst$pagination
# pagination i.e. the number of pages the results make up, given a specific break point
# there are only 4 hits, they all fit on one page
# the hits are sorted in ascending order on the basis of projectTitle
```

```{r}
names(lst$termFacets)
lst$termFacets
# contains a summary of the facets available for composing filters, and the various values those facets take on withing the results of the query
```

---
## 4. Formulate additional filters
- Some examples include:
    - projects using `genusSpecies = "Homo sapiens"`
    - combining filters: projects using `"Mus musculus"` (mouse) to study expression in the brain.

### First, encapsulating the API querying capabilities in functions

- function for constructing the query url
```{r}
construct_query_filter <- function(r_filter = list(), base_url = "https://service.dev.singlecell.gi.ucsc.edu", endpoint = "/index/projects", params = list()){
    # takes list and makes it json
    json_filter <- toJSON(r_filter)
    
    # need to encode url so that curly braces are not escaped, but treated as legal characters
    encoded_filter <- utils::URLencode(json_filter, reserved = TRUE)
    
    # add encoded filter to params
    # help from: https://www.datamentor.io/r-programming/list/
    params[["filters"]] <- encoded_filter
    
    
    # further parameter processing; do names(params) to get parameter key names
    param_key_value <- paste(names(params), params, sep="=")
    
    # format the query by collapsing into single string separated by `&`
    query <- paste(param_key_value, collapse = "&")
    
    # form the URL for the GET query
    # paste with no sep
    # url automatically returned as it is the last statement in the function
    url <- paste0(
        base_url,
        endpoint,
        "?",
        query
    )
}
```

- function for making the API call request
```{r}

hca_api_call <- function(url = ''){
    response <- httr::GET(url)
    tryCatch({
        httr::stop_for_status(response) # make sure response code isn't 400 or higher
    }, error = function(e) {
        ## convert error into a simple 'message' so execution continues
        message(e)
    })
    
    # help returning multiple values: https://stackoverflow.com/questions/8936099/returning-multiple-objects-in-an-r-function
    
    headers <- httr::headers(response) %>%
                utils::str()
    content <- httr::content(response)
    
    resp <- list("headers" = headers, "content" = content)
    return(resp)
}
```

- composed function
```{r}
# putting it all together

hca_base_call <- function(r_filter = list(), base_url = "https://service.dev.singlecell.gi.ucsc.edu", endpoint = "/index/projects", params = list()){
    url <- construct_query_filter(r_filter, base_url, endpoint, params)
    resp <- hca_api_call(url)
    return(resp)
}
```

- testing out the functions
```{r}
# construct a query filter (aiming for `{"organ" : {"is" : ["pancreas"]}}`)
r_filter <- list(
    organ = list(
        is = "pancreas"
    )
)

# putting together base url, endpoint, and other parameters
base_url <- "https://service.dev.singlecell.gi.ucsc.edu"
endpoint <- "/index/projects"

params <- list(
    catalog = "dcp2",
    size = 100,
    sort = "projectTitle",
    order = "asc"
)

out <- hca_base_call(r_filter = r_filter, base_url = base_url, endpoint = endpoint, params = params)
out$headers
out$content
```

### Next, our new queries
***base url and endpoint are not changing***
A. projects using `genusSpecies = "Homo sapiens"`
```{r}
homo_sapien_filter <- list(
    genusSpecies = list(
        is = "Homo sapiens"
    )
)

homo_sapien_params <- list(
    catalog = "dcp2",
    size = 20,
    sort = "projectTitle",
    order = "asc"
)

homo_sapien_results <- hca_base_call(r_filter = homo_sapien_filter, base_url = base_url, endpoint = endpoint, params = homo_sapien_params)

homo_sapien_results$headers
#homo_sapien_results$content

names(homo_sapien_results$content)
lengths(homo_sapien_results$content)

# looking at the project titles
sapply(X = list(homo_sapien_results$content$hits), FUN = extract_proj_titles)
```

B. combining filters: projects using `"Mus musculus"` (mouse) to study expression in the brain.
```{r}
mouse_brain_filter <- list(
    genusSpecies = list(
        is = "Mus musculus"
    ),
    organ = list(
        is = "brain"
    )
)

mouse_brain_params <- list(
    catalog = "dcp2",
    size = 20,
    sort = "projectTitle",
    order = "asc"
)

mouse_brain_results <- hca_base_call(r_filter = mouse_brain_filter, base_url = base_url, endpoint = endpoint, params = mouse_brain_params)

mouse_brain_results$headers
#mouse_brain_results$content

names(mouse_brain_results$content)
lengths(mouse_brain_results$content)

# looking at the project titles
sapply(X = list(mouse_brain_results$content$hits), FUN = extract_proj_titles)
```

---
## 5. Incorporate simple queries like this into an R package (WIP)
- adding each of the functions defined above into the package
- Martin also suggested a function the took query parameters more directly and returned a tibble summary of matching results

```{r}
# parameters are just some of the supported facets
projects <- function(assayType = character(),
                     biologicalSex = character(),
                     fileFormat = character(),
                     genusSpecies = character(),
                     instrumentManufacturerModel = character(),
                     organ = character(),
                     catalog = "dcp2",
                     size = 100,
                     sort = "projectTitle",
                     order = "asc") {
  ## query for appropriate projects -- httr::GET(...)
  r_filter <- list(
    assayType = list(
        is = dplyr::coalesce(assayType, "")
    ),
    biologicalSex = list(
        is = dplyr::coalesce(biologicalSex, "")
    ),
    fileFormat = list(
        is = dplyr::coalesce(fileFormat, "")
    ),
    genusSpecies = list(
        is = dplyr::coalesce(genusSpecies, "")
    ),
    instrumentManufacturerModel = list(
        is = dplyr::coalesce(instrumentManufacturerModel, "")
    ),
    organ = list(
        is = dplyr::coalesce(organ, "")
    ),
  )
  
  base_url <- "https://service.dev.singlecell.gi.ucsc.edu"
  endpoint <- "/index/projects"

  params <- list(
      catalog = catalog,
      size = size,
      sort = sort,
      order = order
  )
  
  query_results <- hca_base_call(r_filter = r_filter,
                                 base_url = base_url,
                                 endpoint = endpoint,
                                 params = mouse_brain_params)
  ## transform the results into a tibble with 1 row per project, 
  ## and addiitonal information about each project, e.g., genusSpecies,
  ## as columns
  ## tibble(projectTitle = ..., genusSpecies = ..., ...)
}
```

~end~
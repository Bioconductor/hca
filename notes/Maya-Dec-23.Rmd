---
title: "Maya-Dec-23.Rmd"
author: "Martin Morgan"
date: "12/23/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Tidyverse

Your basic `data.frame`
```{r}
## built-in data
mtcars
df <- data.frame(
    age=c(32, 37, 27), 
    city = c("NY", "Buffalo", "Rochester"), 
    row.names = c("A", "B", "C")
)
## subset by rows, columns
df[c("A", "C"),]
mtcars[1:4, c("mpg", "cyl", "disp")]
mtcars["Fiat 128", ]
```

enter the [tidyverse][]. A `tibble` is essential a data.frame with additional
behaviors.

[tidyverse]: https://www.tidyverse.org/


```{r}
## BiocManager::install("dplyr")
library(dplyr)
tbl <- as_tibble(mtcars, rownames = "model")
tbl
tibble(
    age=c(32, 37, 27), 
    city = c("NY", "Buffalo", "Rochester"), 
    name = c("A", "B", "C")
)
```

R objects can be interrogated for their class

```{r}
class(mtcars)
class(tbl)   # linear hierarchy of classes
```

The tidyverse encourages the use of 'pipes'...

```{r}
mtcars %>%
    as_tibble(rownames = "model")

tbl <-
    mtcars %>%
    as_tibble(rownames = "model")

## R-devel introduced 'native' pipes
mtcars |>
    as_tibble(rownames = "model")
```

...and 'non-standard' evaluation with a few explict 'verbs' (e.g., `filter()`, `select()`, `mutate()`, `group_by()`, `summarize()`) for data transformation

```{r}
## filter rows based on column values
tbl %>%
    filter(mpg > 20, cyl >= 6)

## select individual columns
tbl %>% 
    select(model, mpg, cyl, disp)

## filter & select
tbl %>%
    filter(mpg > 15) %>%
    select(model, mpg, cyl, disp)

## summarize column(s) of data to scalar metric
tbl %>%
    summarize(
        mean.mpg = mean(mpg),
        mean.disp = mean(disp),
        min.cyl = min(cyl),
        max.cyl = max(cyl)
    )

## perform summaries of each group in the data
tbl %>%
    group_by(cyl) %>%
    summarize(
        mean.mpg = mean(mpg),
        mean.disp = mean(disp)
    )

## mutate to update or add columns
tbl %>%
    mutate(
        sqrt.disp = sqrt(disp)
    ) %>%
    select(model, mpg, disp, sqrt.disp)

```

Good tidyverse functions take as their first object the data to be transformed, and return the same class of object as in the first argument.

# Human Cell Atlas Project

[Human Cell Atlas Data Portal][HCA]

## Biological background

Gene expression of single cells

- Possible to isolate individual cells
- Measure expression of each gene in each cell
- Result: matrix of expressions, with N genes as rows and M cells as columns; N genes might be ~30,000, M cells might be 10,000 - 1,000,000
- matrix of expression values are often sparse -- e.g., 95% of elements of the matrix are 0's

Projects

- Focused on a relatively small number of 'samples' (e.g., 4 humans)
- Data starts as millions of short (e.g., 100 nucleotide) DNA sequences. Represented as 'FASTQ' files.
- FASTQ files are often transformed to BAM or CRAM format, and finally to count matrices
- matrics might be represented as...

  - CSV file (e.g., 1,000,000 columns [cells] and 30,000 rows [genes])
  - '.loom' (based on 'hdf5' [NOT hadoop file system])
  - '.mtx' (text-based sparse matrix representation)
  - ...

## Walking through the GUI

[HCA]: https://data.humancellatlas.org/explore

- Each row reprsents a project
- Information about a project is retrieved by clicking on the project, etc.

## Walking through the API

[HCA API][API] based on 'swagger' (older name) or 'openAPI' that defines endpoints and the parameters used to invoke the endpoint.

For instance `GET /index/projects` to retrieve project of interest. We used `dcp2` for `catalog`, and create a `filter` to select projects involving the pancreas.

```
{ "organ": { "is": [ "pancreas" ] } }
```

Using 'Try it out', we find that the URL is

```
https://service.dev.singlecell.gi.ucsc.edu/index/projects?catalog=dcp2&filters=%7B%20%22organ%22%3A%20%7B%20%22is%22%3A%20%5B%20%22pancreas%22%20%5D%20%7D%20%7D&size=100&sort=projectTitle&order=asc
```

This consists of

- A base URL `https://service.dev.singlecell.gi.ucsc.edu`
- The path to the endpoint `/index/projects`
- parameter values

    - `catalog=dcp2`
    - filter ('URL encoded', e.g., a `' '` becomes `'%20'`) `filters=%7B%20%22organ%22%3A%20%7B%20%22is%22%3A%20%5B%20%22pancreas%22%20%5D%20%7D%20%7D`
    - etc...

- The endpoint returns a JSON value of results.

[API]: https://service.dev.singlecell.gi.ucsc.edu/#

## Accessing the API in R

Use [httr][] and [jsonlite][] packages

```{r}
library(httr)
library(jsonlite)
```

Define the components of our query

Start with the filter (aiming for `'{ "organ": { "is": [ "pancreas" ] } }'`)
```{r}
r_filter <- list(
    organ = list(
        is = "pancreas"
    )
)
json_filter <- toJSON(r_filter)
encoded_filter <- utils::URLencode(json_filter, reserved = TRUE)
encoded_filter
```

Then the base URL, endpoint, and all parameters

```{r}
base_url <- "https://service.dev.singlecell.gi.ucsc.edu"
endpoint <- "/index/project"
parameters <- list(
    catalog="dcp2",
    filters=encoded_filter,
    size=100,
    sort="projectTitle",
    order="as"
)
```

Further process parameters -- associate key and value as individual strings...

```{r}
names(parameters)
parameter_key_value = paste(names(parameters), parameters, sep="=")
parameter_key_value
```

collapse into a single string seperated by `&`

```{r}
query <- paste(parameter_key_value, collapse = "&")
query
```

form the URL for the GET query

```{r}
url <- paste0(
    base_url,
    endpoint,
    "?",
    query
)
```

Now that we have the URL, use it with [httr][]

```{r}
response <- GET(url)
tryCatch({
    stop_for_status(response)
}, error = function(e) {
    ## convert error into a simple 'message' so execution continues
    message(e)
})

httr::headers(response)
lst <- httr::content(response)
## lst$hits$projectTitle... ???
```

TODO

1. Figure out authentication (Martin)

2. Figure out how to parse return value (Maya)

    - What are the `projectTitle` of projects with 'pancreas' as organ? (should be same as [here][])
    
3. Formulate additional filters, projects using `genusSpecies = "Homo sapiens"`

4. Incorporate simple queries like this into an R package.

    ```
    project <- function(organ = character()) {
        ## query for appropriate projects -- httr::GET(...)
        ## ...
        ## transform the results into a tibble with 1 row per project, 
        ## and addiitonal information about each project, e.g., genusSpecies,
        ## as columns
        ## tibble(projectTitle = ..., genusSpecies = ..., ...)
    }
    ```
    
[here]: https://data.humancellatlas.org/explore/projects?catalog=dcp1&filter=%5B%7B%22facetName%22:%22genusSpecies%22,%22terms%22:%5B%22Homo%20sapiens%22%5D%7D,%7B%22facetName%22:%22specimenOrgan%22,%22terms%22:%5B%22pancreas%22%5D%7D%5D
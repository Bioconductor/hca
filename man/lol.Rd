% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lol.R
\name{list-of-lists}
\alias{list-of-lists}
\alias{.lol_visit}
\alias{.lol_visit.list}
\alias{.lol_visit.default}
\alias{lol_find}
\alias{lol_lfind}
\alias{lol_hits}
\alias{lol_hits_path}
\title{Utilities for manipulating lists-of-lists}
\usage{
lol_find(x = list(), key = "", not_in = character(), filter = NA_character_)

lol_lfind(x = list(), key = "", not_in = character(), simplify = TRUE)

lol_hits(x = list(hits = list()), key = "", not_in = character())

lol_hits_path(x = list(hits = list()), all = FALSE)
}
\arguments{
\item{x}{list(), possibly containing other lists.}

\item{key}{character() desired node name, or path to nodes of
interest, e.g., \code{"a.b"} finds "b" nodes that are descendents
(children or more distant) of "a" nodes.}

\item{not_in}{character() node(s) whose descendants are excluded
from matching \code{key}.}

\item{filter}{character(1) regular expression matching paths to be
returned.}

\item{simplify}{logical(1). For \code{lol_lfind()}, when TRUE, unlist
each value before adding, as a list element, to the list of
found items. This is appropriate when the node values are
vectors, or sets with homogenous scalar types. See examples.}
}
\value{
\code{lol_find()} returns a named character vector. The names
represent the paths to each node matching \code{key}, and the
elements correspond to the value of the node. Named keys with
empty elements are represented as \code{NA}.

\code{lol_lfind()} returns an unnamed list of elements matching
\code{key}.

\code{lol_hits()} returns either a vector (if \code{key} evaluates to
a 0- or 1-length value for each element of \code{hit} or
list-of-vectors with each element matching \code{key}. In either
case, the length of the \code{hits} component of \code{x} equaals the
length of the return value.
}
\description{
\code{lol_find()} searches a list-of-lists \code{x} for nodes
with name \code{key}, returning a named vector of scalar-valued
keys.

\code{lol_lfind()} is like \code{lol_find()}, but returns values
as lists-of-lists.

\code{lol_hits()} selects an element \code{hits} from x, and
finds \code{key} values in each hit.
}
\examples{
lol <- list(a = list(b = 1), a = list(b = 2))
lol_find(lol, "b")

lol <- list(list(b = 1), a = list(b = 2))
lol_find(lol, "b")
lol_find(lol, "b", not_in = "a")

## empty key
lol_find(list(a = list(), a = list(1)), "a")  # c(NA, 1)

## 'a.b': choose 'b' nodes that are children of 'a' nodes
lol <- list(a = list(b = 1), c = list(b = 2))
lol_find(lol, "a.b")
lol_find(lol, "b", filter = "a.b")  # same as previous, but less robust
lol <- list(a = list(b = c(1, 2)), a = list(b = 3))
lol_find(lol, "b")  # names() mangled, length() of input and result differ
lol_lfind(lol, "b")

lol <- list(
    person = list(
        age = 32,
        name = list(first = "Ima", last = "Person")
    ),
    person = list(
        age = 27,
        name = list(first = "Iman", last = "Other")
    )
)
lol_lfind(lol, "name")  # simplify names to vectors, e.g., c("Ima", "Person")
lol_lfind(lol, "name", simplify = FALSE)  # retain structure of each element


x <- list(
    hits = list(
        list(projects = list(projectTitle = "A title")),
        list(projects = list(projectTitle = "Another title")),
        list(files = list(projectTitle = "And another title"))
    ),
    termFacets = list(projects = list(projectTitle = c("A", "B", "C")))
)
lol_hits(x, "projects.projectTitle") # c("A title", "Another title")

projects_lol <- projects(as = "lol")
lol_hits_path(projects_lol)

}
